<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on 陈晓拉尼</title>
    <link>https://chenxiaolani.com/categories/javascript/</link>
    <description>Recent content in JavaScript on 陈晓拉尼</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Sun, 06 Jan 2019 17:56:20 +0000</lastBuildDate><atom:link href="https://chenxiaolani.com/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>手动实现一个简单的promise</title>
      <link>https://chenxiaolani.com/2019/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/</link>
      <pubDate>Sun, 06 Jan 2019 17:56:20 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2019/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise/</guid>
      <description>一直在用promise，也想过自己能不能也实现一个简单的promise，但是一直没有时间；这不最近辞职了，时间就多起来了。当然也参考了网上很多人的实现方法。
  本篇文章主要参考自https://github.com/ElemeFE/node-practice/blob/master/control/promise/README.md
  promise的意义就是能够很好的控制异步流程，避免回调地狱；首先来看一下promise的基本用法
 基本实现效果 let p = new Promisee((resolve, reject) =&amp;gt; { setTimeout(() =&amp;gt; { resolve(&amp;#39;hello&amp;#39;) }, 0) }) p.then((val) =&amp;gt; { console.log(val) return &amp;#39;world&amp;#39; }) .then((val) =&amp;gt; { console.log(val) }) 基本书写 当我们想封装一个函数时，我们只关心两个东西，它需要输入什么以及它要输出什么。
 输入一个函数接受两个回调参数 输出一个对象，里面为then函数，函数参数为成功回调和失败回调  function Promisee(fn) { function resolve() { } function reject() { } fn(resolve, reject) // 返回一个对象  return { then: function(onResolve, onReject) { } } } 加入状态模式 promise内部使用了状态模式，根据不同的状态执行不同的逻辑</description>
    </item>
    
    <item>
      <title>js设计模式之迭代器模式</title>
      <link>https://chenxiaolani.com/2019/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 06 Jan 2019 14:20:23 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2019/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。总结两点，第一顺序访问一个集合，第二使用者无需知道集合的内部（封装）。
 迭代器演示 class Iterator { constructor(container) { this.list = container.list this.index = 0 } next() { if(this.hasNext()) { return this.list[this.index++] } return null } hasNext() { if(this.index &amp;gt;= this.list.length) { return false } return true } } class Container { constructor(list) { this.list = list } // 生成遍历器  getIterator() { return new Iterator(this) } } // 测试 let arr = [1,2,3,4,5] let container = new Container(arr) // 生成遍历器 let iterator = container.</description>
    </item>
    
    <item>
      <title>js设计模式之状态模式</title>
      <link>https://chenxiaolani.com/2019/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Jan 2019 01:09:14 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2019/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>状态模式往往会带来代码量的增加，但是它也许是解决某些需求场景的最好方法，状态模式的关键是区分事物内部的状态，事物内部的状态往往会带来事物行为的改变。
 if/else/switch的情况 实际开发中，我们可能会遇到使用大量if/else/switch的情况，根据不同的状态，通过判断执行不同状态对应的逻辑操作，比如如下
//执行动作 function doAction(state){ //state0 	if(state === &amp;#39;0&amp;#39;){ console.log(&amp;#39;执行0&amp;#39;); } //state1 	if(state === &amp;#39;1&amp;#39;){ console.log(&amp;#39;执行1&amp;#39;); } //state2 	if(state === &amp;#39;2&amp;#39;){ console.log(&amp;#39;执行2&amp;#39;); } } 状态变多即使用switch也会越来越繁琐，这时候就可以使用状态模式了。
状态模式改善 状态模式，就是将每一种条件作为对象内部的一种状态，面对不同的判断结果，我们只需选择不同的状态便可.
var ResultState = function(){ //各种情况的业务逻辑保存在内部状态中 	var states = { state1:function(){ console.log(&amp;#39;情况一的业务逻辑&amp;#39;); }, state2:function(){ console.log(&amp;#39;情况二的业务逻辑&amp;#39;); }, state3:function(){ console.log(&amp;#39;情况三的业务逻辑&amp;#39;); } } //获取某一状态的对应逻辑并执行 	function show(state){ states[state] &amp;amp;&amp;amp; states[state](); } return { doActionByState: show } }(); // 传入状态，即会执行状态所对应的业务逻辑。 ResultState.doActionByState(&amp;#39;state1&amp;#39;); promise es6中的promise内部就是一个状态机。</description>
    </item>
    
    <item>
      <title>js设计模式之装饰者模式</title>
      <link>https://chenxiaolani.com/2018/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 24 Dec 2018 23:48:13 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加指责，总结来说就是两点，第一为对象添加新功能，第二不改变原有的结构和功能。
 装饰函数 在javascript中，万物皆对象，函数则是一等对象，当我们想要为函数添加一些功能时，如果直接改写函数，就违背了开放-封闭原则，我们可以保留原有函数的引用，然后直接放到新函数内执行，比如
let frank = function() { console.log(&amp;#34;i am frank&amp;#34;) } // 我们想为frank添加一个技能时，先用临时变量把原有函数存起来 let oldFrank = frank // 放到新的frank函数执行 frank = function() { oldFrank() console.log(&amp;#34;i am best&amp;#34;) } 此做法符合开放-封闭原则，在不改变原函数源代码的情况下为其添加新功能，但是每次添加一个新功能都必须维护一个中间变量（比如oldFrank）,长此以往，要维护的中间变量就会越来越多。
用AOP装饰函数  AOP就是面向切面编程,把一些与核心业务逻辑无关的功能抽离出来 再通过“动态织入”方式掺入业务逻辑模块
 在这里我们需要两个方法，一个是前置装饰，一个是后置装饰
Function.prototype.before = function(beforeFunc){ var that = this; return function(){ beforeFunc.apply(this, arguments); return that.apply(this, arguments); } } Function.prototype.after = function(afterFunc){ var that = this; return function(){ var ret = that.apply(this, arguments); afterFunc.apply(this, arguments); return ret; } } 为了避免污染原型，我们可以改写before和after方法如下</description>
    </item>
    
    <item>
      <title>js设计模式之适配器模式</title>
      <link>https://chenxiaolani.com/2018/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 17 Dec 2018 00:12:11 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>适配器模式是一种简单设计模式，主要是用来解决老接口不兼容的问题，对于不兼容的老接口，我们没必要重写，只需创建一个适配器即可。
 获取城市接口例子 现在我们有一个接口用来获取广东省所有的城市，如下
// 模拟接口，返回广东城市数据  let getGuanDongCity = function() { let guanDongCity = [ { name: &amp;#39;shenzhen&amp;#39;, id: 11 }, { name: &amp;#39;guangzhou&amp;#39;, id: 12 } ] return guanDongCity } // 定义渲染函数  let render = function(fn) { document.write(JSON.stringify(fn())) } // 渲染  render(getGuanDongCity) 然后我们发现这个接口显示的城市并不齐全，我们又找到了另外一个齐全的接口作为补充，这个接口返回的数据格式和原来返回的数据格式不一样，这时候我们要改写原来的接口吗，nono,我们只要为原来的接口包装一个适配函数即可。
// 新的补充接口的数据格式  let guanDongCity = { shenzhen: 11, guangzhou: 12, zhuhai: 13 } 为原来接口编写适配函数
let addressAdapter = function( oldAddressfn ) { let address = {} let oldAddress = oldAddressfn() oldAddress.</description>
    </item>
    
    <item>
      <title>js设计模式之代理模式</title>
      <link>https://chenxiaolani.com/2018/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 05 Dec 2018 22:03:04 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>代理模式的定义：为一个对象提供代用品或占位符，以便控制对它的访问；注意使用者无权访问目标对象的。
  最常见的就是科学上网了  代理模式根据其目的，也有好多种代理
 保护代理（代理掉不必要的请求） 虚拟代理 （创建开销很大的对象时，可以先用一个小对象代替，等到真正使用时再创建） 缓存代理 （为一些开销大的运算提供暂时的存储，如果下次传的参数一致时，可以返回这个结果） 其他代理（在js中适用性不高）  保护代理 // 这个类外面是无权访问的 class ReadImg { constructor(fileName) { this.fileName = fileName this.loadFormDIsk() // 加载，模拟  } loadFormDIsk() { console.log(&amp;#39;loading...&amp;#39; + this.fileName) } display() { console.log(&amp;#39;display...&amp;#39; + this.fileName) } } // 定义代理函数 class ProxyImg { constructor(fileName) { this.realImg = new ReadImg(fileName) } display() { this.realImg.display() } } let proxyImg = new ProxyImg(&amp;#39;1.png&amp;#39;) e6中的proxy 明星经纪人案例
let start = { name: &amp;#39;steven&amp;#39;, age: 24, phone: &amp;#39;12334445&amp;#39; } // 经纪人来代理 let agent = new Proxy(start, { get: function(target, key) { if(key === &amp;#39;phone&amp;#39;) { // 给经纪人自己的号码  return &amp;#39;111121111&amp;#39; } if(key === &amp;#39;price&amp;#39;) { // 经纪人来报价  return 1232333 } return target[key] }, set: function(target, key, val) { if(key === &amp;#39;customPrice&amp;#39;) { if(val &amp;lt; 10000) { throw new Error(&amp;#34;太低&amp;#34;) }else { target[key] = val return true } } } }) 虚拟代理 图片预加载</description>
    </item>
    
    <item>
      <title>js设计模式之单例模式</title>
      <link>https://chenxiaolani.com/2018/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 04 Dec 2018 23:44:21 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例模式的定义: 保证一个类仅有一个实例，并且提供一个访问它的全局访问点。意义为减少内存开支，减少变量冲突。
 常见的应用场景  全局的window对象，Jquery中的$对象 vuex和redux中的state 系统间各种模式的通信协调上  模式实现 最简单的实现，对象字面量的方法
let singleton = { age: 11, name: &amp;#34;frank&amp;#34; } 对象复杂的时候，就需要构造函数，简单的来说当new的时候先判断实例是否存在，如果存在直接返回，不存在就创建一个再返回，这样保证了返回的实例就是同一个。
class Singleton { constructor() { this.instance = null; } // 定义一个静态方法，实例化只能通过静态方法。  static getInstance(name) { if(!this.instance) { this.instance = new Singleton(); } return this.instance; } } let a = Singleton.getInstance() let b = Singleton.getInstance() console.log(a === b) 模拟登陆框 class LoginForm { constructor { this.state = &amp;#39;hide&amp;#39; } show() { // 如果当前已经显示  if(this.</description>
    </item>
    
    <item>
      <title>总结一下JavaScript中的this</title>
      <link>https://chenxiaolani.com/2018/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/</link>
      <pubDate>Tue, 16 Oct 2018 22:09:25 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/%E8%B0%88%E4%B8%80%E8%B0%88javascript%E4%B8%AD%E7%9A%84this/</guid>
      <description>有的时候我们总是被JavaScript中的this搞得晕头转向，因为它的不确定性，也被经常拿来当作考题，我们也经常听到网上最认同的说法：“谁调用this,this就指向谁”，那么this到底是什么呢，最近就this总结了一下。
  本篇文章主要参考《你不知道的JavaScript》（上）
  话说草稿老早就写了，好像忘发了。
 为什么要使用this？ 我们先要知道一个前提，在JavaScript中 万物皆对象，而函数在对象中又是 一等公民，对象与对象之间通过 原型联系，那对象和函数之间如何联系呢，答案就是 this
首先如果没有this会是什么情况？ // 只要切换上下文对象，就可以复用此函数，不用针对每个对象写一遍函数 function sayName(context){ console.log(context.name) } var me = { name: &amp;#39;kyle&amp;#39; } var you = { name: &amp;#39;frank&amp;#39; } // 如果没有this，我们只能显示的传入对象 sayName(me) // 函数的上下文为对象的情况 var obj = { name: &amp;#39;frank&amp;#39; sayName: function(context) { console.log(context.name) } } // 如果没有this，我们只能显示的传入对象 obj.sayName(obj) 我们看到如果没有this，要想函数与对象产生关联，只能手动传入这个对象，那JavaScript的创始者想Java有个this，不如JavaScript也搞个this吧，干脆我就默认帮忙隐式传递这个对象得了！于是就发明了this这个关键字！ 所以结论是this关键字能够隐式的传递对象，当然了也提供了call,apply函数允许我们手动显式传递，上面的情况就可以这样写了。
var obj = { name: &amp;#39;frank&amp;#39; sayName: function() { console.log(this.name) } } // 隐式传递了obj,等同于obj.</description>
    </item>
    
    <item>
      <title>TypeScript入门</title>
      <link>https://chenxiaolani.com/2018/typescript%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 17 Sep 2018 23:25:48 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/typescript%E5%85%A5%E9%97%A8/</guid>
      <description>TypeScript主要提供了类型系统和对ES6的支持,对于一个需要长期维护的项目，使用TypeScript可以减少维护成本。使用VSCode编辑器，默认支持TypeScript，其次需要下载npm install -g typescript，因为我们需要tsc命令来将ts文件编译为js。
  参考教程https://github.com/xcatliu/typescript-tutorial/blob/master/README.md
 基本数据类型 布尔值、数值、字符串、null、undefined Symbol Symbol是ES6中的基本数据类型，返回的值为唯一
类型标注 我们声明变量可以如下声明
let a: boolean = false let b: string = &amp;#39;11&amp;#39; let c: number = 11 let d: null = null let e: undefined = undefined 当然还有 void ,如果一个变量声明为void，那么你只能将它赋值给null和undefined
let a: void = null let a: void = undefined 另外undefined 和 null 是所有类型的 子类型 ，所以你可以将它们赋值给所有类型,下面都不会报错的。
let a: number = null let a: string = undefined let a: boolean = null 使用 any 指定任意类型</description>
    </item>
    
    <item>
      <title>ES6笔记（四）扩展对象的功能性</title>
      <link>https://chenxiaolani.com/2018/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/</link>
      <pubDate>Tue, 03 Apr 2018 16:17:56 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/es6%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/</guid>
      <description>&lt;h3 id=&#34;对象的语法的扩展&#34;&gt;对象的语法的扩展&lt;/h3&gt;
&lt;h4 id=&#34;1对象的属性或属性值可以直接传入变量&#34;&gt;(1)对象的属性或属性值可以直接传入变量&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;:&lt;span style=&#34;color:#66d9ef&#34;&gt;value&lt;/span&gt;} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2在对象中方法的简写&#34;&gt;(2)在对象中方法的简写&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ts&#34; data-lang=&#34;ts&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//es5 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { 
    &lt;span style=&#34;color:#a6e22e&#34;&gt;handle&lt;/span&gt;:&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){ 
        &lt;span style=&#34;color:#75715e&#34;&gt;//dosomething 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        } 
    } 
&lt;span style=&#34;color:#75715e&#34;&gt;//es6 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
     &lt;span style=&#34;color:#a6e22e&#34;&gt;handle&lt;/span&gt;(){ 
        &lt;span style=&#34;color:#75715e&#34;&gt;//dosomething 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        } 
    } 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>ES6笔记（三）函数</title>
      <link>https://chenxiaolani.com/2018/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 02 Apr 2018 11:31:08 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/es6%E7%AC%94%E8%AE%B0%E4%B8%89%E5%87%BD%E6%95%B0/</guid>
      <description>函数参数的默认值 以前es5的做法是这样的：
function log(x) { x = x || 10; console.log(x) } 这样做的坏处是有的时候我想传一个空字符，也会被修改为默认值 es6的做法直接在括号内写上默认值
function log(x=10) { console.log(x) } 这种写法就没有上面那种问题，需要注意的是函数参数一般会放在arguments里，你用ES6这种方法的话，arguments里面是没有滴。
reset参数 function say(a,b,...items){ // dosomething...  } 当我们不知道参数个数时，可以用展开运算符&amp;hellip;的形式，主义他只能放在最后一个参数的位置，而且他跟arguments不同，他是真数组，意味着你可以用Push，pop等方法。
箭头函数 ES6 允许使用“箭头”（=&amp;gt;）定义函数。如下：
var a = (v) =&amp;gt; v; 两点注意：
 函数参数没有或者只有一个时可以省略括号，返回值只有一个时也可以省略； （ 箭头函数没有自己的this，他的this指的是上下文的this,也就是说我们再也不用that = this或者self=this这样的形式了。当然箭头函数也要看场合使用，比如不要在object和原型里面定义箭头函数,因为这时候的this是指向window的。  尾调用优化 尾调用就是在函数的内部最后调用函数需要注意下面的都不算：
// 情况一 function f(x){ let y = g(x); return y; } // 情况二 function f(x){ return g(x) + 1; } // 情况三 function f(x){ g(x); } 尾调用优化的原理： 当我们调用一个函数a时，在内存中会形成一个call frame（调用帧），里面记录着a的变量信息，如果在函数a里面再调用函数B,同样会形成一个call frame位于a的调用帧上方，如此嵌套调用，多个call frame就会形成call stack(调用栈)，所谓优化就是在a的调用帧之上b的调用帧如果用不到a里面的信息的话，a的调用帧就会舍弃掉。 注意：ES6中的尾调用优化只在use strict下生效，看下面例子：</description>
    </item>
    
    <item>
      <title>ES6笔记（二）字符串和正则表达式</title>
      <link>https://chenxiaolani.com/2018/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Fri, 30 Mar 2018 14:46:41 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/es6%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>字符串
字符串模板 字符串模板用``来表示，示例如下:
let template = `${变量1}` 可以看到字符串模板主要有两个特点
 字符串换行不再需要+来拼接，里面的空格换行都会保留； 字符串里可以用${}的形式来表示变量，当然这里也可以写一些简单的表达式如${1+1}或是三元表达式${a=1?true:false},还可以调用函数${fn()};  标签模板 标签模板的意思就是可以用函数来调用字符串模板，当然这个函数的参数有规定的。示例如下：
//先定义这个函数  function tag (arr, ...arg){ //...表示不确定参数个数  console.log(arr); console.log(...arg); } // 准备一个变量  let world = 20; let sayHi= 66; // 函数调用  tag(hello, ${ world },${sayHi}) 从上面看出，这个函数的规则就是第一个参数是一个数组，里面放的是普通的字符串，而第二个参数就是${}里面的变量，一般用标签模板来过滤HTML字符串，了解即可，用的多的还是字符串模板。
关于字符串编码  我们经常听到utf-8，它是一种通用的字符编码格式，但其实js里面对于字符串采用的是utf-16来处理的； 不管是utf-8还是utf-16都是Unicode码的一种实现，什么是Unicode码呢？不需要了解太多，你只要知道这是一个能代表任何字符的大集合就好了； 在js里字符的表示形式是这样的\uxxxx,xxxx叫做码点，对于码点大于0XFFFF的字符来讲，ES5是不能正确处理的，ES6对此完善，并提供了一些API如下：  codePointAt(index) //传入索引值，返回其对于位置的码点  String.fromCodePoint() //传入码点，返回对应字符串  at(index) //返回给定位置的字符  normalize() //顾名思义格式化，了解即可 关于字符串的一些方法 有个印象就好，废话不多说上API:
includes(str, index)//如果在字符串中检测到指定文本，返回true，否则false。  startsWith(str, index)//如果在字符串起始部分检测到指定文本，返回true，否则返回false。  endsWith(str, index)//如果在字符串的结束部分检测到指定文本，返回true，否则返回false。  str.</description>
    </item>
    
    <item>
      <title>ES6笔记（一）块级作用域的绑定</title>
      <link>https://chenxiaolani.com/2018/es6%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Fri, 30 Mar 2018 10:28:22 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2018/es6%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%BB%91%E5%AE%9A/</guid>
      <description>前言 在学习的过程中也用过不少ES6语法，比如箭头函数，promise，class等，但从来没有好好的从头捋一遍，es6是2015年出的，现在都2018了，再不好好看看就out了。
新的声明方式
let 在ES6中又出现了两种声明方式分别是let，和const，在此之前js的作用域只有全局作用域和函数包裹的作用域，而let的出现让js有了块级作用域，一个经典案例一看就明白：
for(let i = 0;i&amp;lt; 4;i++){ console.log(i) } console.log(i)//这里是i is not defined 可以看出用let来声明变量，其变量的作用域只存在于这个花括号内，此时花括号就是一个块级作用域，而如果用var声明的话，在外面是可以打印出i的值的，因为它仍然处于全局作用域下，所以我们平时在写代码时完全可以用let来代替var，现在js语法越来越严谨，var早晚会out的。还有要注意的是let不能重复声明变量以及不存在变量提升。
const const用来定义一些不可改变的变量，比如我用到的在node端引入一些包依赖用const
const express = require(&amp;#39;express&amp;#39;); const app = express(); 总之你不想他被改变就用const，而且他和let一样会形成块级作用域，不能重复声明，不存在变量提升。</description>
    </item>
    
    <item>
      <title>原生js封装ajax</title>
      <link>https://chenxiaolani.com/2017/%E5%8E%9F%E7%94%9Fjs%E5%B0%81%E8%A3%85ajax/</link>
      <pubDate>Tue, 12 Dec 2017 14:20:24 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/%E5%8E%9F%E7%94%9Fjs%E5%B0%81%E8%A3%85ajax/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;面试大概率会考到&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>数组去重的三种方法</title>
      <link>https://chenxiaolani.com/2017/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 12 Dec 2017 11:36:40 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description> 一、利用indexOf方法剔除  var newArr = [] function removeArr (arr) { for (var i = 0;i &amp;lt; arr.length; i++){ // 如果等于-1的话，push进newArr  if(newArr.indexOf(arr[i] === -1)) { newArr.push(arr[i]) } } return newArr } 二、利用sort方法相邻比较 function removeArr(arr) { // 先排序，这样相同的值都是相邻的  arr.sort() // 先把第一个值放进新数组  var newArr = [arr[0]] for(var i = 1;i &amp;lt; arr.length;i++) { // 如果旧数组的值与新数组的值不一样就Push i  f(arr[1] !== newArr[newArr.length - 1]) { newArr.push(arr[i]) } } return newArr } 三、利用对象属性名是否重复 </description>
    </item>
    
    <item>
      <title>数组内元素随机排序的三种方法</title>
      <link>https://chenxiaolani.com/2017/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 11 Dec 2017 23:38:06 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/%E6%95%B0%E7%BB%84%E5%86%85%E5%85%83%E7%B4%A0%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>一、利用数组方法sort  // 数组的sort方法，如果a&amp;gt;b,则正序排，a 二、经典的洗牌算法 // 我们先定义一个随机函数,用于取到x-y区间的随机数 function getRandom(min, max) { // +1是为了取到上限，  return Math.floor(Math.random() * (max - min + 1) + min) } function shuffle(arr) { // for 循环，随机替换掉每一个数组元素  for(var i = 0; i &amp;lt; arr.length; i++) { // 取一个随机数  var j = getRandom(0,arr.length) var x = arr[j] arr[i] = arr[j] arr[j] = x } return arr } 三、push进新数组 // 递归思想，每执行一次，取一个数组索引的随机数，如此反复，直到数组长度为一，结束循环 function randomArr(arr, newArr) { if(arr.</description>
    </item>
    
    <item>
      <title>js中对数组的一些操作</title>
      <link>https://chenxiaolani.com/2017/js%E4%B8%AD%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 11 Oct 2017 13:28:08 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/js%E4%B8%AD%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</guid>
      <description>对于angular，还是先放放，国庆期间看了点VUe.js,最近这两天在FCC（free code camp）刷题，以前学的知识又忘了，看到数组的几个方法怕记不住，还是写下来吧。
 插入与删除   push：末尾插入； pop:末尾删除； shift:开头删除； unshift:开头添加；  map 迭代数组，在回调函数中处理相关逻辑，并且返回新数组，不会改变原来数组 比如：  var oldArray = [1,2,3,4,5]; var newArray = oldArray.map(function(val){ return val+3; }); reduce 迭代数组，作用将数组累加到一个值中，两个常用参数（总共4个），preValue和currValue; 比如：  var array = [4,5,6,7,8]; var singleVal = 0; singleVal = array.reduce(function(pre,curr){ return pre+curr; },0); filter（过滤器）  var oldArray = [1,2,3,4,5,6,7,8,9,10]; var newArray = oldArray.filter(function(val){ return val&amp;lt;6; }); sort 方法，你可以很容易的按字母顺序或数字顺序对数组中的元素进行排序。 比如：从小到大排列  var array = [1, 12, 21, 2]; array.sort(function(a, b) { return a - b; }); reverse 方法来翻转数组，无参数。 比如：  var array = [1,2,3,4,5,6,7]; var newArray = []; newArray = array.</description>
    </item>
    
    <item>
      <title>表单验证（ajax&#43;jQuery Validate&#43;PHPgd2）</title>
      <link>https://chenxiaolani.com/2017/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81ajax-jquery-validate-phpgd2/</link>
      <pubDate>Fri, 25 Aug 2017 14:42:59 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81ajax-jquery-validate-phpgd2/</guid>
      <description>一般在我们浏览器端负责输入数据格式的验证，在服务器端利用ajax技术查询验证输入数据是否重复
 一、浏览器端的验证我们可以用jQuery Validate这个插件  首先引入插件：  &amp;lt;script src=&amp;#39;libs/jquery-1.11.1.min.js&amp;#39;&amp;gt;&amp;lt;/script&amp;gt;/ //jquery插件 &amp;lt;script src=&amp;#39;libs/jquery.validate.min.js&amp;#39;&amp;gt;&amp;lt;/script&amp;gt; //jQuery validate插件 &amp;lt;script src=&amp;#39;libs/messages_zh.min.js&amp;#39;&amp;gt;&amp;lt;/script&amp;gt; //中文提示信息插件 具体使用看如下例子：   js部分  $(function(){ //指定要验证的表单  $(&amp;#39;#myform&amp;#39;).validate({ //这里是验证通过要书写回调函数  submitHandler:function(form){ //提交表单方式之一  form.submit(); } //这里定义规则  rules:{ username:{ requried:true, minlength:2 } } //这里写提示信息，如果不写，就会使用默认  messages:{ username:{ required:&amp;#34;请输入用户名！&amp;#34;, minlength:&amp;#34;长度不少于2位！&amp;#34; } } }) }) 更多的其他的指令规则：规则 描述   required:true 必须输入的字段。 remote:&amp;ldquo;check.php&amp;rdquo; 使用 ajax 方法调用 check.php 验证输入值。 email:true 必须输入正确格式的电子邮件。 url:true 必须输入正确格式的网址。 date:true 必须输入正确格式的日期。日期校验 ie6 出错，慎用。 dateISO:true 必须输入正确格式的日期（ISO），例如：2009-06-23，1998/01/22。只验证格式，不验证有效性。 number:true 必须输入合法的数字（负数，小数）。 digits:true 必须输入整数。 creditcard: 必须输入合法的信用卡号。 equalTo:&amp;quot;#field&amp;quot; 输入值必须和 #field 相同。 accept: 输入拥有合法后缀名的字符串（上传文件的后缀）。 maxlength:5 输入长度最多是 5 的字符串（汉字算一个字符）。 minlength:10 输入长度最小是 10 的字符串（汉字算一个字符）。 rangelength:[5,10] 输入长度必须介于 5 和 10 之间的字符串（汉字算一个字符）。 range:[5,10] 输入值必须介于 5 和 10 之间。 max:5 输入值不能大于 5。 min:10 输入值不能小于 10。  小提示：可以使用label.</description>
    </item>
    
    <item>
      <title>ajax复习</title>
      <link>https://chenxiaolani.com/2017/ajax%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Thu, 24 Aug 2017 12:13:55 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/ajax%E5%A4%8D%E4%B9%A0/</guid>
      <description>ajax是一种在不刷新页面的情况下，局部更新数据的一种技术，XMLHTTPRequest对象是ajax的基础。 使用ajax有以下4个步骤：
 （1）创建XMLHTTPRequest对象
所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。
兼容性写法如下：
var xmlhttp; if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else { // code for IE6, IE5 xmlhttp=new ActiveXObject(&amp;#34;Microsoft.XMLHTTP&amp;#34;); } （2）向服务器发送请求
这里我们使用open()和send()方法 open(method，url,flag),open()方法中有三个参数：
method：请求方式，有get和post两种；
url:要请求页面的地址，相对地址或绝对地址
flag：true是异步，false是同步
注意点：
 get和post的比较：get传输数据小且不安全，post传输数据大且安全； 使用post方式时，注意添加http请求头协议； send(string),send()中有一个参数，当使用GET方式请求时，里面没有参数，使用post方式时，里面写上传输的数据； 示例get请求：  xmlhttp.open(&amp;#39;get&amp;#39;,&amp;#39;123.php&amp;#39;,true); xmlhttp.send(); 示例post请求：
xmlhttp.open(&amp;#39;post&amp;#39;,&amp;#39;123.php&amp;#39;,&amp;#39;true&amp;#39;); //添加http请求头信息 xmlhttp.setRequestHeader(&amp;#34;Content-type&amp;#34;,&amp;#34;application/x-www-form-urlencoded&amp;#34;); xmlhttp.send(&amp;#34;name=lili&amp;amp;amp;age=10&amp;#34;); 服务器的响应 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据。 onreadystatechange 事件 当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。  下面是 XMLHttpRequest 对象的三个重要的属性： onreadystatechange属性，每当readyState属性变化时就会调用该函数； readyState属性，它有四种状态变化：</description>
    </item>
    
    <item>
      <title>JavaScript基础知识复习（五）函数的四种调用模式</title>
      <link>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%BA%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 09 Aug 2017 19:35:54 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%BA%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;&lt;strong&gt;一、函数模式&lt;/strong&gt;
这个我们再熟悉不过了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-JavaScript&#34; data-lang=&#34;JavaScript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(){
    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);
}
&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//这里函数名调用，就是函数模式
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：这里的this指的是window全局对象；
&lt;strong&gt;二、方法模式&lt;/strong&gt;
函数放在对象内，是对象的一个属性，我们调用函数，这就是方法模式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{
  &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){
      &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);
  }
}
&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>javascript基础知识复习（四）递归与闭包</title>
      <link>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E5%9B%9B%E9%80%92%E5%BD%92%E4%B8%8E%E9%97%AD%E5%8C%85/</link>
      <pubDate>Wed, 09 Aug 2017 17:55:48 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E5%9B%9B%E9%80%92%E5%BD%92%E4%B8%8E%E9%97%AD%E5%8C%85/</guid>
      <description>&lt;h2 id=&#34;递归&#34;&gt;递归&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;递归概念：在函数内调用函数自己，就是递归。 注意：递归要有结束条件，没有递归结束条件的递归，就是死递归。&lt;/li&gt;
&lt;li&gt;使用递归的方法：化归思想。化归思想是将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。
例子：求1-100的和 利用划归思想：var sum=foo(100); 1.求foo（100）即求foo（99）+100； 2.求foo（99），即求foo（98）+99； 3.求foo（98），即求foo（97）+98； &amp;hellip; 最后求foo（1），就是1;//这就是约束条件 最后利用递归，函数就是：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;( &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; ) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; ) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;( &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;利用递归可以解决很多问题，比如算出阶乘，算出斐波那契数列等；&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>js中的作用域及变量提升</title>
      <link>https://chenxiaolani.com/2017/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</link>
      <pubDate>Mon, 07 Aug 2017 21:35:02 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</guid>
      <description>一、作用域
作用域有：块级作用域和词法作用域；  块级作用域：使用{}包裹起来的，里面的变量外面是不可以访问的，js没有块级作用域，js里外面是可以访问{}里的变量的; 词法作用域：词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是所谓词法作用域.js中有词法作用域。  在 js 中词法作用域规则:
 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字  作用域链 概念：只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。
凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 如下代码:
function f1() { function f2() { } } var num = 456; function f3() { function f4() { } } 它的作用域链图就是： 绘制作用域链的步骤:
 看整个全局是一条链, 即顶级链, 记为 0 级链 看全局作用域中, 有什么成员声明, 就以方格的形式绘制到 0 级练上 再找函数, 只有函数可以限制作用域, 因此从函数中引入新链, 标记为 1 级链 然后在每一个 1 级链中再次往复刚才的行为 变量的访问规则 首先看变量在第几条链上, 在该链上看是否有变量的定义与赋值, 如果有直接使用 如果没有到上一级链上找( n - 1 级链 ), 如果有直接用, 停止继续查找.</description>
    </item>
    
    <item>
      <title>javascript基础知识复习（三）js中的继承</title>
      <link>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%B8%89js%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Mon, 07 Aug 2017 15:37:44 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%B8%89js%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</guid>
      <description>js中共有6种继承 一、原型链
function SuperType(){ this.prototype=true; } SuperType.prototype.getSuperValue=function(){ return this.property } function SubType(){ this.subPrototy=false; } //继承了SuperType SubType.prototype=new SuperType(); SubType.prototype.getSubValue=function(){ return this.subProperty; } var instance = new SubType(); console,log(instance.getSuperValue);//true console.log(instance.getSubValue);//false 以上代码我们可以看到定义两个构造函数，里面有属性，原型里面有方法，我们让SubType的原型等于SuperType的实例，通过替换了SubType的默认原型对象实现继承，我们可以看到SubType的实例成功调用SuperType里的方法，之后我们又为其手动添加了一个新的方法也是可以调用的。
注意：继承原型后使用字面量添加方法，会使继承无效，因为已经替换了原型，我们在上一篇中介绍原型时已经讲过。 缺点：（1）继承后的原型对应的构造函数它所有的实例都会共享原型中的方法。 （2）继承的子类和父类，子类是不能向父类传参数的。
二、借用构造函数
function SuperType (){ this.colors=[&amp;#39;red&amp;#39;,&amp;#39;blue&amp;#39;]; } function SubType(){ //用call或者apply将调用对象换成SuperType实现对SuperType函数的继承 //this指向当前对象  SuperType.call(this); } var o=new SubType(); o.colors.push(&amp;#39;black&amp;#39;); console.log(o);//red,blue,black var o1=new SubType(); console.log(o1)//red,blue  //利用call()或apply()在子类函数中调用父类函数实现继承，我们可以看到SubType的实例并不共享属性；而且子类也是可以向父类传参的  function SuperType (name){ this.name=name; } function SubType(){ SuperType.call(this，&amp;#39;lili&amp;#39;); this.age=12; } var o=new SubType(); console.</description>
    </item>
    
    <item>
      <title>javascript基础知识复习（二）面向对象</title>
      <link>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%BA%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sun, 06 Aug 2017 18:36:39 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%BA%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>一、什么是面向对象？与面向过程又有什么关系？
 面向对象是一种思维方式，解决的重点放在对象上； 面向过程也是一种思维方式，解决的重点放在详细的步骤上； 举个例子：如何去超市买东西？  从面向对象的角度出发，我们只需要一辆车，还有自己就好了； 从面向过程的角度出发，我们要先拿钱，打开门，开车，进超市； 一句话概括它们之间的关系就是：面向对象是面向过程的封装。    二、js中的对象
js中键值对的集合就是对象。
三、创建对象的几种方法
 使用字面量创建对象  var 0={name:&amp;#39;lili&amp;#39;,age:&amp;#39;12&amp;#39;}; 这种方法会造成代码冗余，资源浪费；
使用内置构造函数创建对象  var o =new Object(); o.name=&amp;#39;lili&amp;#39;; o.age=&amp;#39;12&amp;#39;; 创建的代码是空对象，需要为其手动添加对象属性；
工厂模式  function createObj(age,name){ var o=new Object(); o.age=age; o.name=name; o.sayHi=function(){ alert(&amp;#39;你好&amp;#39;)； }； return o; } var o1=new createObj(){&amp;#39;12&amp;#39;,&amp;#39;lili&amp;#39;}; 每次调用时都会为这个函数在内存中开辟空间，浪费资源。
自定义构造函数，注意函数名要大写  function MyObj(name,age){ this.name=name; this.age=age; this.sayHi=function(){ console.log(&amp;#39;hi&amp;#39;); }; } var myobj=new MyObj(&amp;#39;lili&amp;#39;,&amp;#39;12&amp;#39;); this指的是new出来的对象（即调用者）,和工厂模式差不多，每次调用的时候都会为里面的函数开辟新的内存地址，但是函数的代码功能却是相同的，造成内存资源浪费。
自定义构造函数模式原型模式组合 所以我们需要引入原型概念，将构造函数里的属性和方法分开，将方法放到原型里实现共享。 原型概念：在构造函数创建出来的时候，系统会默认的帮构造函数创建并关联一个神秘的对象，这个对象就是原型，原型默认的是一个空的对象。 原型中的属性和方法，都可以被使用该构造函数创建出来的对象使用。给原型添加属性和方法可以使用构造函数的prototype属性，所以第四种方法可以这样修改：  function MyObj(name,age){ this.</description>
    </item>
    
    <item>
      <title>javascript基础知识复习（一）基本概念</title>
      <link>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%B8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sun, 06 Aug 2017 16:50:11 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%E4%B8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>一、js的组成
 ECMAScript：js的核心，规范了js的语法； DOM：文档对象模型，提供了操作DOM元素的API； BOM：浏览器对象模型，对浏览器对象API的操作；  二、js的数据类型
 简单数据类型（也称基本数据类型）：Undefined,Null,Boolean,String,Number; 复杂数据类型：Object，本质由一组无序的名值对组成；  三、js中的部分关键字
 in：判断属性是否存在于对象中，for in遍历对象的键； typeOf:判断对象的类型，返回是String类型； delete：  删除对象的属性; 删除未使用var声明的变量; 返回值为boolean 表示是否删除成功; 注意：删除的属性如果不存在，返回true; 删除的如果是原型中的属性，返回true 但是删除不成功;   ==和=== (a)==：判断值是否相等； (b)===：判断数据类型和值是否相等； ||和&amp;amp;&amp;amp;；  四、js中的值类型和引用类型
 值类型（又叫基本类型）：存储的是数据本身的值，有数值、布尔值、null、 undefined; 值类型赋值：将数据赋值一份给新的变量，两份变量单独存在，互不影响； 引用类型：存储的是数据的地址，而其中的数据会在内存中单独存储； 引用类型赋值：会将存储数据的地址赋值一份，两个地址指向同一个变量，因此， 通过其中一个地址修改变量时，另一个地址指向的变量也会改变；  五、js中的异常处理
 基本格式：  try{ //可能出现异常的代码 } catch(e){ //e就是出现异常的异常信息 //出现异常后的处理代码 } finally{ //不管有没有出现异常，都会执行的代码 //一般用来释放资源 } 如何手动抛出异常： throw 任何东西， catch中会抓到该东西</description>
    </item>
    
    <item>
      <title>用面向对象实现歌曲的增删改查</title>
      <link>https://chenxiaolani.com/2017/%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E6%AD%8C%E6%9B%B2%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
      <pubDate>Sun, 06 Aug 2017 01:41:37 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E6%AD%8C%E6%9B%B2%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;自定义构造函数，在其原型对象上书写增删改查函数，再调用拼接字符串到HTML页面即可； 构造函数如下：&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>js特效之三大家族、event事件</title>
      <link>https://chenxiaolani.com/2017/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Tue, 01 Aug 2017 20:30:14 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/js%E7%89%B9%E6%95%88%E4%B9%8B%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8Fevent%E4%BA%8B%E4%BB%B6/</guid>
      <description>老是忘，好好整理一下。 三大家族：offset（位移）、scroll（卷页）、client（可视区）。
offset家族( 5个属性)  offsetWidth和offsetHeight：检测盒子自身的宽高； 注意：包含盒子的padding和border。 offsetWidth=width+padding+border; offsetHeight=height+padding+border； offsetLeft和offsetTop：检测距离父盒子有定位的左侧和上面的距离； 注意：父盒子没有定位，往上找有定位的盒子，如果都没有以body为准，从父盒子的 padding开始算，border不算。 offsetParent：用于获取该元素中有定位的最近父级元素； 注意：如果当前元素的父级元素都没有进行定位,那么offsetParent为body。 （4）与style.width/height/top/left的比较；    offset家族只可以只读，而style系列可以读写；
  offset家族返回的是数值类型（四舍五入），style系列返回的是字符串（带px），特殊情况：在父盒子有定位的情况下，offsetLeft==style.left（没有 px）;
  offsetLeft 和 offsetTop 可以返回没有定位的元素的left值和top值,而style 不可以。
  scroll家族（4个属性）   scrollWidth和scrollHeight：检测内容的宽高； 注意：如果内容超出盒子，显示内容的高度，如果不超出盒子，IE567可以显示实际内 容宽高，IE8+火狐+谷歌显示盒子大小。
  scrollTop和scrollLeft（有兼容性问题）：网页被浏览器遮住的头部和左边的部 分；
  处理兼容性问题： - 未声明 DTD（谷歌只认识他）（火狐IE9+认识他） document.body.scrollTop/scrollLeft - 已经声明DTD（IE678只认识他）(火狐IE9+认识他) document.documentElement.scrollTop/scrollLeft - 火狐/谷歌/ie9+以上支持的(不管DTD) window.pageYOffest/pageXOffest 兼容性写法： var scrollTop = window.pageYOffset ||document.documentElement.scrollTop || document.body.scrollTop||0; 封装scroll方法 function Scroll() { return { &amp;ldquo;left&amp;rdquo;: window.</description>
    </item>
    
    <item>
      <title>旋转轮播图</title>
      <link>https://chenxiaolani.com/2017/%E6%97%8B%E8%BD%AC%E8%BD%AE%E6%92%AD%E5%9B%BE/</link>
      <pubDate>Mon, 31 Jul 2017 09:29:27 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/%E6%97%8B%E8%BD%AC%E8%BD%AE%E6%92%AD%E5%9B%BE/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;与一般轮播图不同，用缓动动画做，我们需要简单封装一个缓动框架&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>选项卡应用</title>
      <link>https://chenxiaolani.com/2017/%E9%80%89%E9%A1%B9%E5%8D%A1%E5%BA%94%E7%94%A8/</link>
      <pubDate>Wed, 19 Jul 2017 15:34:36 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/%E9%80%89%E9%A1%B9%E5%8D%A1%E5%BA%94%E7%94%A8/</guid>
      <description> 很多时候我们需要用到选项卡应用，比如手机京东的商品分类； js代码：
 window.onload=function(){ var tabLi=document.querySelectorAll(&amp;#39;.tab li&amp;#39;); var tabDiv=document.querySelectorAll(&amp;#39;.content Div&amp;#39;); for (var i = 0; i &amp;lt; tabLi.length; i++) { tbLi[i].index=i; tabLi[i].onclick=function(){ for (var i = 0; i &amp;lt; tabLi.length; i++) { tabLi[i].className=&amp;#39;&amp;#39;; tabDiv[i].style.display=&amp;#39;none&amp;#39;; } this.className=&amp;#39;current&amp;#39;; tabDiv[this.index].style.display=&amp;#39;block&amp;#39;; }; }; } </description>
    </item>
    
    <item>
      <title>Js中的css样式</title>
      <link>https://chenxiaolani.com/2017/js%E4%B8%AD%E7%9A%84css%E6%A0%B7%E5%BC%8F/</link>
      <pubDate>Thu, 13 Jul 2017 13:45:17 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/js%E4%B8%AD%E7%9A%84css%E6%A0%B7%E5%BC%8F/</guid>
      <description>js中css样式的不同 1、 JavaScript使用驼峰命名法，而css不是。 比如css中的‘border-radius’，js中的‘borderRadius’； 2、 JavaScript的属性值用字符串表示，而css不是。 比如js中div.style.backgroundColor=&#39;&#39;;css中div{}；</description>
    </item>
    
    <item>
      <title>js特效之带有定时器的无缝轮播图（offset家族）</title>
      <link>https://chenxiaolani.com/2017/js%E7%89%B9%E6%95%88%E4%B9%8B%E5%B8%A6%E6%9C%89%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD%E5%9B%BEoffset%E5%AE%B6%E6%97%8F/</link>
      <pubDate>Sun, 21 May 2017 02:42:52 +0000</pubDate>
      
      <guid>https://chenxiaolani.com/2017/js%E7%89%B9%E6%95%88%E4%B9%8B%E5%B8%A6%E6%9C%89%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD%E5%9B%BEoffset%E5%AE%B6%E6%97%8F/</guid>
      <description>1.了解offset家族，这里用到offsetLeft(盒子距离左侧的距离)，与style.left不同，style.left可被赋值且盒子要定位。动画原理：盒子本身的位置+位长，用offsetLeft来获取值，style.left来赋值。以下是动画的简单封装。
function animate(ele,target) { //每次调用计时器时都要清除计时器  clearInterval(ele.timer); //调用计时器  //位长让它有正有负  var speed=target&amp;gt;ele.offsetLeft ? 10:-10; ele.timer=setInterval(function () { var val=target-ele.offsetLeft; ele.style.left=ele.offsetLeft+speed+&amp;#34;px&amp;#34;; if(Math.abs(val)&amp;lt;=10){ ele.style.left=target+&amp;#34;px&amp;#34;; clearInterval(ele.timer); } },30); } 2.思路：实现无缝滚动，先复制第一张图片到ul最后，当滚动到第六张时，将ul的offsetLeft值赋值为0（此时转到第一张），并将ul 的索引值赋值为1，切换到第二张，js代码如下： var all = document.getElementById(&amp;#34;all&amp;#34;); var screen = all.firstElementChild || all.firstChild;//all元素的第一个元素的第一个子节点  var imgWidth = screen.offsetWidth; var ul = screen.firstElementChild || screen.firstChild; var div = screen.lastElementChild || screen.lastChild; var spanArr = div.children; var ol = screen.children\[1\]; //2.复制第一张图片所在的li,添加到ul的最后面。  var ulNewLi = ul.children\[0\].cloneNode(true);//复制ul中第一个节点  ul.</description>
    </item>
    
  </channel>
</rss>
